// types/db.ts
import type {
  PostType,
  Visibility,
  PostTag,
  QuestTaskStatus,
  LinkedItem,
  GitStatus,
  GitLinkedItem,
  GitMetaData,
  UserRole,
  BoardLayout,
  BoardType,
  ReactionSet,
  ReactionCountMap,
  ReviewTargetType,
  ApprovalStatus,
  GitAccount,
} from './api';

// types/db.ts
export interface DBPost {
  /** Primary key */
  id: string;
  /** Foreign key to users.id */
  authorId: string;
  /** Post category */
  type: PostType;
  /** Optional short header */
  title?: string | null;
  /** Body content */
  content: string;
  /** Creation timestamp */
  createdAt: string;

  // --- Optional fields retained for JSON store / compatibility ---
  subtype?: string;
  /** Optional extra details for task posts */
  details?: string;
  visibility?: Visibility;
  timestamp?: string;
  replyTo?: string | null;
  repostedFrom?: string | null;
  reactions?: ReactionSet;

  tags?: PostTag[];
  status?: QuestTaskStatus;
  /** Optional classification for task posts */
  taskType?: 'file' | 'folder' | 'abstract';
  collaborators?: { userId?: string; roles?: string[]; pending?: string[] }[];
  linkedItems?: LinkedItem[];

  systemGenerated?: boolean;
  autoGeneratedReason?: string;

  linkedNodeId?: string;
  gitDiff?: string;
  commitSummary?: string;

  enriched?: boolean;

  /** Flag indicating this post is requesting help */
  helpRequest?: boolean;

  /** Whether this request still needs help */
  needsHelp?: boolean;

  /** Pointer to a generated request post */
  requestId?: string;

  questId?: string | null;
  questNodeTitle?: string;
  nodeId?: string;

  /** Optional board association */
  boardId?: string;

  /** Optional rating value for review posts */
  rating?: number;

  reactionCounts?: ReactionCountMap;

  /** Users following this post */
  followers?: string[];
}

// types/db.ts
export interface DBQuest {
  /** Primary key */
  id: string;
  /** Foreign key to users.id */
  authorId: string;
  title: string;
  description?: string | null;
  visibility: Visibility;
  approvalStatus?: ApprovalStatus;
  status?: 'active' | 'completed' | 'archived';

  /** Optional parent project association */
  projectId?: string | null;

  headPostId?: string | null;
  linkedPosts?: LinkedItem[];
  collaborators?: { userId?: string; roles?: string[]; pending?: string[] }[];

  gitRepo?: {
    repoId: string;
    repoUrl?: string;
    headCommitId?: string;
    defaultBranch?: string;
  };
  createdAt: string;
  tags?: string[];
  /** When true this quest appears on the Quest Board */
  displayOnBoard?: boolean;
  defaultBoardId?: string;
  taskGraph?: TaskEdge[];

  /** Marks this quest as a request for help */
  helpRequest?: boolean;

  /** Users following this quest */
  followers?: string[];
}

export interface TaskEdge {
  from: string; // Node ID
  to: string; // Node ID
  type?: 'sub_problem' | 'solution_branch' | 'folder_split';
  label?: string;
}

export interface DBProject {
  id: string;
  authorId: string;
  title: string;
  description?: string | null;
  visibility: Visibility;
  status?: 'active' | 'completed' | 'archived';
  tags: string[];
  createdAt: string;
  questIds: string[];
  deliverables: string[];
  mapEdges?: TaskEdge[];
}

// types/db.ts
export interface DBBoard {
  id: string;
  title: string;
  description?: string;
  boardType: BoardType;
  layout: BoardLayout;
  items: (string | null)[];
  filters?: Record<string, any>;
  featured?: boolean;
  defaultFor?: 'home' | 'profile' | 'quests';
  createdAt: string;
  category?: string;
  userId: string;
  /** Optional quest association */
  questId?: string;
}

// Efficient DB model for quick lookups and storage
export interface BoardDB {
  id: string;
  title: string;
  description?: string;
  type: BoardType;
  layout: BoardLayout;
  items: (string | null)[];
  filters?: Record<string, any>;
  featured?: boolean;
  defaultFor?: 'home' | 'profile' | 'quests';
  createdAt: string;
  userId: string;
  category?: string;
}


export interface DBGitRepo {
  repoUrl: string;
  defaultBranch: string;
  branches: string[];
  lastCommitSha: string;
  status: GitStatus;
  lastSync?: string;
  files?: DBGitFile;
}

export interface DBGitFile {
  path: string;
  name: string;
  type: string;
  status: string;
  linkedTo?: GitLinkedItem;
  commits?: DBGitCommit;
}

export interface DBGitCommit {
  id: string;
  message: string;
  authorId: string;
  timestamp: string;
  files: string[]; // array of file paths or file IDs
  parentShas?: string[];
  linkedItem?: GitLinkedItem;
  tags?: string[];
  metadata?: GitMetaData;
}

export interface DBUser {
  id: string;
  email: string;
  username?: string;
  password: string;
  role?: UserRole | string;
  status?: string;

  // --- optional profile fields ---
  name?: string;
  bio?: string;
  avatarUrl?: string;
  tags?: string[];
  location?: string;

  /**
   * Total experience points accumulated.
   */
  xp?: number;

  gitAccounts?: GitAccount[];

  links?: Record<string, string>; // generic key-value links
  featuredPosts?: Array<{
    title: string;
    url: string;
    type?: string;
    tags?: string[];
  }>;

  experienceTimeline?: DBUserExperienceEvent[];

  /** Users following this user */
  followers?: string[];

  /** Accounts this user follows */
  following?: string[];

  createdAt?: string;
  updatedAt?: string;
}

export interface DBUserExperienceEvent {
  datetime: string;
  title: string;
  tags?: string[];
}

export interface DBReview {
  id: string;
  reviewerId: string;
  targetType: ReviewTargetType;
  rating: number;
  visibility: 'private' | 'public';
  status: 'draft' | 'submitted' | 'accepted';
  tags: string[];
  feedback?: string;
  repoUrl?: string;
  modelId?: string;
  questId?: string;
  postId?: string;
  createdAt: string;
}

export interface DBNotification {
  id: string;
  userId: string;
  message: string;
  link?: string;
  read?: boolean;
  createdAt: string;
}

export interface DBBoardLog {
  id: string;
  boardId: string;
  action: 'create' | 'update' | 'delete';
  userId: string;
  timestamp: string;
}

/**
 * Represents the in-memory or file-backed layout of your JSON data store.
 * You can expand this to include reaction data, logs, etc.
 */
export interface DBSchema {
  boards: DBBoard[];
  git: DBGitRepo[];
  posts: DBPost[];
  projects: DBProject[];
  quests: DBQuest[];
  users: DBUser[];
  reactions: string[];
  reviews: DBReview[];
  boardLogs: DBBoardLog[];
  notifications: DBNotification[];
}

// Optional utility type for referencing a single entry type by file
export type DBFileName = keyof DBSchema;

/**
 * Generic type for file-based mock storage (can be used in utils/loaders.ts)
 */
export type DataStore<T> = {
  read: () => T;
  write: (data: T) => void;
  filepath?: string; // Optional path reference
};