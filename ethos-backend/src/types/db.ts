// types/db.ts
import type { 
  PostType,
  Visibility, 
  PostTag, 
  QuestTaskStatus, 
  LinkedItem, 
  GitStatus,
  GitLinkedItem,
  GitMetaData,
  UserRole,
  BoardLayout,
  BoardType,
  ReactionSet,
  ReactionCountMap,
  ReviewTargetType,
  ApprovalStatus
} from './api';

// types/db.ts
export interface DBPost {
  id: string;
  authorId: string;
  type: PostType;
  subtype?: string;
  /** Short header for the post */
  title?: string;
  content: string;
  /** Optional extra details for task posts */
  details?: string;
  visibility: Visibility;
  timestamp: string;
  createdAt?: string;

  replyTo?: string | null;
  repostedFrom?: string | null;
  reactions?: ReactionSet;

  tags?: PostTag[];
  status?: QuestTaskStatus;
  /** Optional classification for task posts */
  taskType?: 'file' | 'folder' | 'abstract';
  collaborators?: { userId?: string; roles?: string[]; pending?: string[] }[];
  linkedItems?: LinkedItem[];

  systemGenerated?: boolean;
  autoGeneratedReason?: string;

  linkedNodeId?: string;
  gitDiff?: string;
  commitSummary?: string;

  enriched?: boolean;

  /** Flag indicating this post is requesting help */
  helpRequest?: boolean;

  /** Whether this request still needs help */
  needsHelp?: boolean;

  /** Pointer to a generated request post */
  requestId?: string;

  questId?: string | null;
  questNodeTitle?: string;
  nodeId?: string;

  /** Optional board association */
  boardId?: string;

  /** Optional rating value for review posts */
  rating?: number;

  reactionCounts?: ReactionCountMap;

  /** Users following this post */
  followers?: string[];
}

// types/db.ts
export interface DBQuest {
  id: string;
  authorId: string;
  title: string;
  description?: string;
  visibility: Visibility;
  approvalStatus: ApprovalStatus;
  flagCount?: number;
  status: 'active' | 'completed' | 'archived';

  /** Optional parent project association */
  projectId?: string;

  headPostId: string;
  linkedPosts: LinkedItem[];
  collaborators: { userId?: string; roles?: string[]; pending?: string[] }[];

  gitRepo?: {
    repoId: string;
    repoUrl?: string;
    headCommitId?: string;
    defaultBranch?: string;
  };
  createdAt?: string;
  tags?: string[];
  /** When true this quest appears on the Quest Board */
  displayOnBoard?: boolean;
  defaultBoardId?: string;
  taskGraph?: TaskEdge[];

  /** Marks this quest as a request for help */
  helpRequest?: boolean;

  /** Users following this quest */
  followers?: string[];
}

export interface DBProject extends DBQuest {
  questIds: string[];
}

export interface TaskEdge {
  from: string; // Node ID
  to: string; // Node ID
  type?: 'sub_problem' | 'solution_branch' | 'folder_split';
  label?: string;
}

export interface DBProject {
  id: string;
  authorId: string;
  title: string;
  description?: string;
  visibility: Visibility;
  status: 'active' | 'completed' | 'archived';
  tags?: string[];
  createdAt?: string;
  quests?: string[];
  deliverables?: string[];
  mapEdges?: TaskEdge[];
}

// types/db.ts
export interface DBBoard {
  id: string;
  title: string;
  description?: string;
  boardType: BoardType;
  layout: BoardLayout;
  items: (string | null)[];
  filters?: Record<string, any>;
  featured?: boolean;
  defaultFor?: 'home' | 'profile' | 'quests';
  createdAt: string;
  category?: string;
  userId: string;
  /** Optional quest association */
  questId?: string;
}

// Efficient DB model for quick lookups and storage
export interface BoardDB {
  id: string;
  title: string;
  description?: string;
  type: BoardType;
  layout: BoardLayout;
  items: (string | null)[];
  filters?: Record<string, any>;
  featured?: boolean;
  defaultFor?: 'home' | 'profile' | 'quests';
  createdAt: string;
  userId: string;
  category?: string;
}


export interface DBGitRepo {
  repoUrl: string;
  defaultBranch: string;
  branches: string[];
  lastCommitSha: string;
  status: GitStatus;
  lastSync?: string;
  files?: DBGitFile;
}

export interface DBGitFile {
  path: string;
  name: string;
  type: string;
  status: string;
  linkedTo?: GitLinkedItem;
  commits?: DBGitCommit;
}

export interface DBGitCommit {
  id: string;
  message: string;
  authorId: string;
  timestamp: string;
  files: string[]; // array of file paths or file IDs
  parentShas?: string[];
  linkedItem?: GitLinkedItem;
  tags?: string[];
  metadata?: GitMetaData;
}

export interface DBUser {
  id: string;
  email: string;
  username: string;
  role: UserRole;

  name?: string;
  bio: string;
  avatarUrl?: string;
  tags: string[];
  location?: string;

  /**
   * Total experience points accumulated.
   */
  xp?: number;

  links?: Record<string, string>; // generic key-value links
  featuredPosts?: Array<{
    title: string;
    url: string;
    type?: string;
    tags?: string[];
  }>;

  experienceTimeline?: DBUserExperienceEvent[];

  /** Users following this user */
  followers?: string[];

  /** Accounts this user follows */
  following?: string[];

  status?: 'active' | 'archived' | 'banned';
  createdAt?: string;
  updatedAt?: string;
}

export interface DBUserExperienceEvent {
  datetime: string;
  title: string;
  tags?: string[];
}

export interface DBReview {
  id: string;
  reviewerId: string;
  targetType: ReviewTargetType;
  rating: number;
  visibility: 'private' | 'public';
  status: 'draft' | 'submitted' | 'accepted';
  tags?: string[];
  feedback?: string;
  repoUrl?: string;
  modelId?: string;
  questId?: string;
  postId?: string;
  createdAt: string;
}

export interface DBNotification {
  id: string;
  userId: string;
  message: string;
  link?: string;
  read?: boolean;
  createdAt: string;
}

export interface DBBoardLog {
  id: string;
  boardId: string;
  action: 'create' | 'update' | 'delete';
  userId: string;
  timestamp: string;
}

/**
 * Represents the in-memory or file-backed layout of your JSON data store.
 * You can expand this to include reaction data, logs, etc.
 */
export interface DBSchema {
  boards: DBBoard[];
  git: DBGitRepo[];
  posts: DBPost[];
  projects: DBProject[];
  quests: DBQuest[];
  users: DBUser[];
  reviews: DBReview[];
  boardLogs: DBBoardLog[];
  notifications: DBNotification[];
}

// Optional utility type for referencing a single entry type by file
export type DBFileName = keyof DBSchema;

/**
 * Generic type for file-based mock storage (can be used in utils/loaders.ts)
 */
export type DataStore<T> = {
  read: () => T;
  write: (data: T) => void;
  filepath?: string; // Optional path reference
};